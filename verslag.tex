\title{Semantiek van Io}
\author{
          Tim van Dijk
          S4477073
        \and
          Nikki van der Gouw
          S4463412
        \and
          Robin Tonen 
          S4486668
}
\date{\today}

\documentclass[12pt]{article}
\usepackage{listings} 
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[dutch]{babel}
\usepackage[bottom]{footmisc}
\usepackage{listings}
\graphicspath{{images/}}

\lstset{breaklines = true}

\begin{document}
\maketitle

\begin{abstract}
Dit werkstuk beschrijft de syntax en semantiek van Io, een puur objectge\"orienteerde programmeertaal.
Hierbij wordt gebruik gemaakt van natuurlijke semantiek. Vervolgens gebruiken we de beschreven syntax en semantiek om
de mogelijkheden van Io te vergelijken met die van While.
\end{abstract}

%Zorg dat je een korte inleiding schrijft waarin je zo concreet mogelijk uitlegt wat je gaat doen.
%Beschrijf hierbij ook wat er zo bijzonder is aan het gekozen onderwerp ten opzichte van de standaardtaal While.
%Neem in de inleiding ook alvast een voorbeeldprogramma op waarin iets interessants gebeurt.
%Zo'n programma helpt om duidelijk te krijgen hoe programma's in jullie taal er uitzien.
\section{Introductie Io}
Io, een programmeertaal, is in 2002 gemaakt door Steve Dekorte omdat hij zijn begrip over de werking van programmeertalen wilde verbreden.
Het bijzondere aan Io is dat het een heel minimalistische en puur objectge\"orienteerde programmeertaal is en gebaseerd op prototypes. De taal is ge\"inspireerd door Smalltalk. Alles, inclusief objecten, bestaat uit 'messages' die worden doorgegeven.
Dit houdt in dat er alleen maar objecten bestaan en dat overerving plaats vindt door bestaande objecten te clonen.
Ook is Io een dynamische taal, dus objecten kunnen tijdens runtime uit worden gebreidt.

Het doel van dit werkstuk is om de mogelijkheden van Io te vergelijken met die van de standaardtaal While.
Om die vergelijking te kunnen maken moet eerst vast worden gelegd hoe de taal precies werkt.
We leggen daarom eerst de syntax vast en daarna de semantiek. Bij het vastleggen van de semantiek gebruiken we natuurlijke semantiek.
Daarna werken we de semantiek uit van een wat groter voorbeeld.

Bij een objectge\"orienteerde taal zoals Io komen veel nieuwe concepten langs, zoals prototypen, inheritance etc. De kracht van ons project wordt dan ook om al de mogelijkheden van objecten 
%en messages? 
zo goed mogelijk uit te werken.  Bovendien willen we kijken of we zonder keywords zoals for en while toch dezelfde functionaliteit kunnen krijgen.

%Misschien dat we dit voorbeeld dan toch wel moeten houden. Tim vond het volgens mij echt een heel leuk voorbeeld.
\subsection*{Voorbeeld}
Om een idee te krijgen van hoe een programma eruit ziet in Io, volgt hier een voorbeeld:
\begin{lstlisting}[frame=single]
Sheep := Object clone
Sheep legCount := 4
MutantSheep := Sheep clone
MutantSheep legCount = 7
dolly := MutantSheep clone
MutantSheep growMoreLegs := method(n, legCount = legCount + n)
dolly growMoreLegs(2)
\end{lstlisting}
Dit voorbeeld is afkomstig van \url{andriybuday.com/2012/07/io-programming-language.html}.
Dit voorbeeld gaan we (hoogstwaarschijnlijk) binnenkort vervangen door een voorbeeld dat we zelf hebben geschreven, want er komen in dit voorbeeld niet genoeg
eigenschappen van Io aan bod. Ook vinden wij het lang niet uitdagend genoeg om uit te werken in het hoofdstuk Analyse.

\section{Syntax}
%Zorg dat je een beschrijving geeft van de syntax die je gaat gebruiken. Dat kan natuurlijk al een complete grammatica zijn, maar op dit moment is het voldoende om hier te beschrijven welke constructies uitgewerkt gaan worden. In het bijzonder geef je hier aan of je de hele taal gaat beschrijven of slechts een deel er van. Verwacht je nu al problemen bij de beschrijving van de syntax, benoem die hier dan al.

De syntax van Io is relatief eenvoudig en beperkt, en bevat weinig gereserveerde termen zoals gebruikelijk in andere talen. Termen als 'if', 'while' en 'for' zijn bijvoorbeeld in veel talen gereserveerde termen, maar niet in Io. Wel gelijk aan de meeste talen is dat een programma simpelweg een expressie is. In Io bestaat een expressie uit messages en terminatoren.

% \[ expr ::= \{message | terminator\}\]
\begin{lstlisting}
	exp		::= { message | terminator }
\end{lstlisting}
Waarbij we een terminator defineren als een newline, of een expliciet terminator karakter.
%\[ terminator ::= ''\backslash n'' | '';''\]
\begin{lstlisting}
	terminator ::= "\n" | ";"
\end{lstlisting}
Meteen is te zien dat eigenlijk alles in Io een message is, aangezien buiten de terminator een expressie niets anders kan zijn dan een message. Een message defineren we als volgt:
%\[ message ::= symbol [a	rguments]\]
%\[ symbol ::= identifier | number | string\]
\begin{lstlisting}
	message		::= symbol [arguments]
	symbol		::= identifier | number | string
\end{lstlisting}

%todo: Volgens de regels zouden we nu ook, net als in While, vast moeten leggen wat een identifier, number of string nou eigenlijk inhoud.
Een identifier heeft de volgende syntax:
%\[Identifier ::= \{ letter | digit | "_" \}\]
%\[letter ::= ''a'' ... ''z'' | ''A'' ... ''Z''\]
%\[digit ::= "0" ... "9"\]
\begin{lstlisting}
	identifier 	::= { letter | digit | "_" }
	letter 		::= "a" ... "z" | "A" ... "Z"
	digit 		::= "0" ... "9"
\end{lstlisting}

Een string kan als volgt gerepresenteerd worden:
% Triquote weglaten?
\begin{lstlisting}
	quote 		::= MonoQuote | TriQuote
	MonoQuote 	::= """ [ "\"" | not(""")] """
	TriQuote 	::= """"" [ not(""""")] """""
\end{lstlisting}
Een nummer ziet er als volgt uit:
%todo: Wat voor getallen willen we hebben? Voor ons lijken me Ints genoeg. Dus dan zijn de .a an b.a notaties overbodig.
% Hex getallen weggelaten net als .xxx en a.b notaties. 
\begin{lstlisting}
	number    	::= Decimal
	Decimal  	::= digits | "." digits |digits "." digits ["e" [-] digits]
	digit 		::= "0" ... "9"
	digits 		::= { digit }
\end{lstlisting}

Een message kan enkel een symbol zijn, maar arguments kunnen worden doorgegeven. Arguments worden omvat door ronde haken, en opgedeelt door een komma.
%\[ arguments ::= ''\left('' [ expr [ \{'','' expr \}] ] ''\right)''\]
\begin{lstlisting}
	arguments 	::= "(" [exp [{ "," exp }]] ")"
\end{lstlisting}
\subsection{Operatoren}
Voor het gemak van de programmeur zijn er enkele operatoren opgenomen in de taal. Zo is het mogenlijk om de infix-variant van de plus-operator te schrijven.
\begin{lstlisting}[frame=single]
6 + 4;
\end{lstlisting}
Deze word voor de compilatie eerst door de parser vertaald naar de variant die aan de syntax voldoet:
\begin{lstlisting}[frame=single]
6 +(4);
\end{lstlisting}
Waar \(6\) en \(+\) messages zijn, en \( (4) \) het argument is van de message \(+\), zichzelf bestaand uit de message \(4\). Dezelfde vertaling van een bekende infix notatie naar de in de syntax correcte vorm word gebruikt voor assignments. Zo accepteert de parser de volgende expressies:
\begin{lstlisting}[frame=single]
x ::= 4;
y := 5;
z = 6;
\end{lstlisting}
En vertaald deze eerst naar de volgens de syntax correcte vormen:
\begin{lstlisting}[frame=single]
newSlot("x", 4);
setSlot("y", 5);
updateSlot("z", 6);
\end{lstlisting}

De volledige syntax is te vinden op: \url{http://iolanguage.org/guide/guide.html#Appendix}

\section{Semantiek}
%Zorg dat je een beschrijving geeft van de semantiek die je gaat gebruiken. Ga je voor ns, sos of nog heel iets anders? En waarom? Probeer ook vast iets te zeggen over de concepten die je nodig hebt: wat zijn je toestanden (als je toestanden gebruikt), wat zijn je transities, welke types spelen een rol, etcetera. Natuurlijk hoef je hier nog geen complete lijst met semantiekregels te geven, maar je moet al wel een idee hebben hoe je denkt te gaan werken. Verwacht je nu al problemen bij de beschrijving van de semantiek, benoem die hier dan al.

\subsection{Messages}
%todo Zoek uit welke parseervolgorde Io gebruikt. 
% Unaire methoden worden eerder uitgevoerd dan Binaire.
% Bij clonen wordt in het prototype gezocht naar de goede functie. Dus als in de parent een functie verandert, verandert die functie in de clone ook.  
Een belangrijk aspect van IO is het door Smalltalk geinspireerde message-passing. Er wordt een message gestuurd naar een object a. Deze geeft als resultaat een nieuw object a'. Het volgende message wordt naar a' gestuurd enzovoorts.  Op deze manier kunnen programmas worden opgebouwd uit opeenvolgingen van messages. Neem bijvoorbeeld dit eenvoudig programma:
%6 +(3) print is incorrect. Dit moet 6 +((3) print)  zijn. Misschien dat een ander voorbeeld duidelijker is.
\begin{lstlisting}[frame=single]
6 +(3)
\end{lstlisting}
De message 6 wordt aan de Lobby doorgegeven. Dit levert een object op van het nummer $6$. (De lobby is de nameSpace. Alle variabelen die je aanmaakt worden hierin opgeslagen.) Hier wordt het volgende message naartoe gestuurd: $+(3)$. Het object 6 heeft een methode + die wordt aangeroepen met de parameter 5 en een object oplevert met de 2 waarden opgeteld. Hier krijg je dus het nummer 9 uit.  

%De eerste expressie is eenvoudigerweg het nummer '6'. Dit nummer wordt als message doorgegeven aan de volgende expressie \('+(3)'\). Deze expressie telt 3 op bij aan deze doorgegeven message. Het resultaat daarvan, in dit geval het nummer '9', word daarna weer verder gegeven aan de volgende expressie. De laatste expressie, 'print', ontvangt deze message en zet deze op de standaard IOstream.\par

In een eenvoudige taal als While kunnen we een state-transitie voorstellen op de volgende manier:
\[\langle S,s \rangle \rightarrow \prime s\]
In ons geval is de state s de state van de nameSpace en dus de Lobby.
Voor Io is het belangrijk dat het resultaat van de message doorgegeven moet worden aan de volgende message. Daarom introduceren we een object 'o'.
%todo Willen we hier een -message-, of een -symbol-? message kan namelijk nog argumenten bevatten, is dat wel wat we willen? We moeten nog even kijken naar wat er mogenlijk is in Io.
% ik zou hier objecten van maken.
\begin{lstlisting}
	o ::= object | Lobby
\end{lstlisting}
Deze bevat of het resultaat van een message, ofwel de Lobby als er nog geen message is verstuurd, of als een expressie dit expliciet wil doorgeven. We moeten nu de standaard state-transitie aanpassen. We voegen het resultaat toe:
\[\langle o,S,s \rangle \rightarrow \langle \prime o,\prime s \rangle\]
Daarnaast moeten we ook vastleggen dat het programma begint met \[o = Lobby\]. Het eenvoudigste voorbeeld is de semantiek van de terminator:
\[[Terminator] = \langle o, terminator, s\rangle \rightarrow \langle Nil, s\rangle\]

\subsection{Objecten}
Objecten bestaan uit een lijst met key/value paren. Zo'n paar wordt een slot genoemd.
in zo'n slot kun je zowel variabelen als messages zetten.
% bijvoorbeeld:
% method()
Een van de methodes die we sowieso willen implementeren is de method functie. 
Deze functie maakt nieuw object aan, initialiseerd de slots en zet de proto pointer en self slot naar het doelwit van de message. 
% block()
%	return()
% super()
% if(<condition>, <do message>, <else do message>)
% verschillende vormen van assignment (:== := en =)
% repeat
% while
% break en continue
% Lists

\section{Analyse}
%Zorg dat je kort beschrijft wat voor een analyse je gaat doen. Heb je bijvoorbeeld al een mooi stuk voorbeeldcode waarvan je uiteindelijk wil laten zien dat het precies doet wat in je semantiekregels hebt vastgelegd, geef dat voorbeeld dan reeds expliciet aan. Dit mag natuurlijk het voorbeeld uit de inleiding zijn, maar het hoeft niet.
Na het vastleggen van de syntax en semantiek willen we hier een wat uitgebreider programma uitwerken. De bedoeling is om in ieder geval de behandelde aspecten van de taal Io te gebruiken (Het doorgeven van messages, en het gebruik van objecten). We zullen een programma moeten schrijven dat deze aspecten van de taal gebruikt en combineerd, zoals het doorgeven van een object als message.

\section{Conclusie}

\appendix
%Zorg dat je in een appendix een globale planning opneemt.
%Hierbij is het natuurlijk niet de bedoeling dat je alleen maar opschrijft wanneer de deadlines zijn uit het weekoverzicht,
%maar het gaat er juist om dat je aangeeft op welke datum je welk deel van het werkstuk af hebt.
%Wanneer is het hoofdstuk over syntax af? Wanneer liggen de concepten van de semantiek vast? 
%Wanneer liggen de regels van de semantiek vast? Enzovoorts.
%In het uiteindelijke werkstuk is die planning natuurlijk verdwenen, want dan is het werkstuk klaar...
\section{Planning}
Vrijdag 29 april: \\Het werkstuk voldoet aan de eisen van eerste versie.\newline\newline %hebben we een alternatief voor 2x \newline?
Dinsdag 10 mei: \\Het hoofdstuk over de syntax van Io is helemaal klaar en willen we al aardig op weg zijn met de semantiek.\newline\newline
Dinsdag 24 mei: \\Het hoofdstuk over de semantiek is compleet. We bedoelen hier niet mee dat dat hoofdstuk helemaal klaar en perfect is, maar
dat het zodanig is dat we het kunnen gebruiken om de rest van het werkstuk te kunnen maken.\newline\newline
Vrijdag 27 mei: \\Het werkstuk voldoet aan de eisen van de tweede versie. Dat wil zeggen: het inleidende hoofdstuk is af, het hoofdstuk over de syntax is af, het hoofdstuk over de semantiek is af, het hoofdstuk over de analyse bevat in elk geval het programma geanalyseerd gaat worden.\newline\newline
Vrijdag 17 juni: \\De definitieve versie van het werkstuk is gereed en ingeleverd.


\end{document}  
