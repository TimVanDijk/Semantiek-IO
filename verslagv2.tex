\title{Semantiek van Io}
\author{
          Tim van Dijk
          S4477073
        \and
          Nikki van der Gouw
          S4463412
        \and
          Robin Tonen 
          S4486668
}
\date{\today}

\documentclass[12pt]{article}
\usepackage{listings} 
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[dutch]{babel}
\usepackage[bottom]{footmisc}
\usepackage{listings}
\graphicspath{{images/}}
\usepackage{stmaryrd}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{ stmaryrd }
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\graphicspath{{images/}}
\lstset{breaklines = true}
\newcommand{\RB}{\mathcal{RB}}
\newcommand{\n}{\newline}

\begin{document}
\maketitle

\begin{abstract}
Dit werkstuk beschrijft de syntax en semantiek van een door Io geinspireerde uitbreiding van While, genaamd WhileIo. Io is een puur objectge\"orienteerde programmeertaal. Hierbij wordt WhileIo met natuurlijke semantiek beschreven. Vervolgens gebruiken we de beschreven syntax en semantiek om
de mogelijkheden van Io te laten zien.
\end{abstract}

%Zorg dat je een korte inleiding schrijft waarin je zo concreet mogelijk uitlegt wat je gaat doen.
%Beschrijf hierbij ook wat er zo bijzonder is aan het gekozen onderwerp ten opzichte van de standaardtaal While.
%Neem in de inleiding ook alvast een voorbeeldprogramma op waarin iets interessants gebeurt.
%Zo'n programma helpt om duidelijk te krijgen hoe programma's in jullie taal er uitzien.
\section{Introductie Io}
Io, een programmeertaal, is in 2002 gemaakt door Steve Dekorte omdat hij zijn begrip over de werking van programmeertalen wilde verbreden.
Het bijzondere aan Io is dat het een heel minimalistische en puur objectge\"orienteerde programmeertaal is die gebaseerd is op prototypes. De taal is ge\"inspireerd door Smalltalk. Alles, inclusief objecten, bestaat uit `messages' die worden doorgegeven.
Dit houdt in dat er alleen maar objecten bestaan en dat overerving plaats vindt door bestaande objecten te clonen.
Ook is Io een dynamische taal, dus objecten kunnen tijdens runtime uit worden gebreidt.

Het doel van dit werkstuk is om de mogelijkheden van Io te verwerken in de standaardtaal While. Hierbij zullen we een eigen definitie geven van objecten en definieren we onze eigen manier om berichten door te geven aan objecten (message passing). Hierbij zullen we eerst vastsleggen hoe Io werkt en hoe dit verschilt met het door ons gemaakte WhileIo. Hierbij zullen we een voorbeeld gebruiken dat in Io geschreven is en vertalen naar ons eigen WhileIo. Vervolgens leggen we de syntax en semantiek van WhileIo vast door middel van natuurlijke semantiek. Tot slot werken we het hierboven genoemde voorbeeld uit met de door ons gedefinieerde semantiek. 

Bij een objectge\"orienteerde taal zoals Io komen veel nieuwe concepten langs, zoals prototypen, inheritance etc. De kracht van ons project wordt dan ook om al de mogelijkheden van objecten zo goed mogelijk uit te werken.  Bovendien willen we kijken of we zonder keywords zoals for en while toch dezelfde functionaliteit kunnen krijgen.


%Misschien dat we dit voorbeeld dan toch wel moeten houden. Tim vond het volgens mij echt een heel leuk voorbeeld.
\subsection*{Voorbeeld}
Om een idee te krijgen van hoe een programma eruit ziet in Io, volgt hier een voorbeeld:
\begin{lstlisting}[frame=single]
Sheep := Object clone
Sheep legCount := 4
MutantSheep := Sheep clone
MutantSheep legCount = 7
Dolly := MutantSheep clone
MutantSheep growMoreLegs := method(n, legCount = legCount + n)
Dolly growMoreLegs(2)
\end{lstlisting}
Dit voorbeeld is afkomstig van \url{andriybuday.com/2012/07/io-programming-language.html} en laat een aantal interessante eigenschappen van Io aan bod komen. Laten we eens kijken wat er in dit voorbeeld gebeurt.\newline

In de eerste regel maken we een clone van Object. Object is het prototype dat er altijd vanaf het begin al is,
alle prototypes die er later bij komen zijn op Object gebaseerd.
Zoals de naam al suggereert maak je, als je een prototype clonet, een nieuwe instantie van dat prototye.
Deze nieuwe instantie heeft precies dezelfde structuur en kenmerken als het prototype waar het uit gecloned is.
Als er later veranderingen worden gemaakt aan het prototype dat gecloned is, dan hebben die ook effect op het nieuwe prototype.
Sheep is dus een nieuw prototype die precies hetzelfde kan en eruit ziet als Object.\newline

Dan willen we zeggen dat het schaap vier poten heeft.
We doen dit door Sheep een nieuw attribuut te geven ``legCount'' en dit attribuut stellen we gelijk aan 4.
Hoewel Sheep een clone is van Object, zijn het verschillende instanties, en dus krijgt object er geen attribuut ``legCount'' bij.\newline

Ons schaap is veel te saai. Dit gaan we oplossen door een gemuteerd schaap te maken door een clone te maken van Sheep. Vervolgens zeggen we door het attribuut ``legCount'' op 7 te zetten.\newline

Vervolgens maken we weer een clone van ons gemuteerde schaap. Deze clone noemen we dolly. De naam dolly, is naar conventie zonder hoofdletter geschreven.
Dit is om het idee te geven dat het een instantie is van het object MutantSheep.
Dit is alleen om het programmeren overzichtelijker te maken, want Io maakt geen onderscheid tussen objecten en instanties: er zijn alleen maar prototypes.\newline


Daarna gaan we een nieuwe methode maken en toevoegen aan MutantSheep, namelijk growMoreLegs.
growMoreLegs neemt \'e\'en argument n en verhoogt ``legCount'' met die n. Zoals eerder gezegd worden veranderingen op een prototype ook overgedragen op prototypes die eruit gecloned zijn. dolly heeft deze methode nu dus ook en kan er gebruik van maken.\newline

Ten slotte willen we dolly nog een paar extra poten geven; twee om precies te zijn.
Om dit te doen maken we gebruik van de nieuwe functie growMoreLegs.
We roepen de methode growMoreLegs van dolly aan met argument 2.
De methode verhoogt het attribuut legCount van dolly met 2.
Uiteindelijk heeft dolly dus 9 poten.

\pagebreak
\section{Syntax}
Voor het definieren van de Syntax maken we gebruik van de volgende sets:
$n$ is een cijfer, Num. \\
$a$ is een arithmetische expressie, $Aexp$. \\
$b$ is een booleaanse expressie, $Bexp$. \\
$S$ is een statement, $Stm$. \\
$x$ is een variabelennaam, $Var$. \\

Het verschil met While is dat we ook de lege declaratie gebruiken:
$E$ is de lege declaratie.

\begin{lstlisting}
a  ::= n | a1 + a2 | a1 * a2 | a1 - a2 | var
b ::= true | false | a1 = a2 | a1 <= a2 | ~b | b1 /\ b2 | var 
var ::= x | FROM var CALL x
i ::= a | b | m
M ::= S END 
Dv ::= E | VAR x := i; Dv
S ::= SKIP | S1;S2 | IF b THEN S1 | WHILE b DO S1
| CLONE var_p AS var_c | FROM var CALL x_i Dv | SET var_o SLOT var_i TO i
\end{lstlisting}

\pagebreak
\section{Semantiek}

Als basis gebruiken we de semantiek van While, die we op een paar plekken uitbreiden en aanpassen.
Zo blijven de booleaanse waarden en nummers gelijk aan while:

We definieren nummers als:
\begin{lstlisting}
n ::= 0 | 1 | n0 | n1
\end{lstlisting}

Om deze nummers om te zetten naar echte getallen gebruiken we de volgende functie:
$$
\begin{matrix}
\mathcal{N}: Num \rightarrow Z \\
\mathcal{N}\llbracket 0 \rrbracket &= &0  \\
\mathcal{N}\llbracket 1 \rrbracket &= &1 \\
\mathcal{N}\llbracket n0 \rrbracket &= &2 * \mathcal{N}\llbracket n \rrbracket \\
\mathcal{N}\llbracket n1 \rrbracket &= &2 * \mathcal{N}\llbracket n \rrbracket + 1 \\
\end{matrix}
$$

Onze eigen toevoeging is natuurlijk objecten. Deze definieren we als volgt:
$$Object : Var \rightarrow Inhoud$$ 
Hierbij is Inhoud alles watje in een object zou kunnen stoppen: 
$$Inhoud = Z \cup \{tt,ff\} \cup Object \cup Stm$$ 

Hierbij gebruiken we dezelfde notatie als bij WHile om de inhoud van zo'n object weer te geven.
Neem een object o met als waarden x = 4 en y = true. Dit wordt als volgt gerepresenteerd:
$$[x \mapsto 4, y \mapsto tt]$$

Nu de basistypen gedefinieerd zijn kunnen we met de echte semantiek verder. Om te beginnen passen we de basisovergang van While aan. Deze is normaal gedefineerd als:
$ \langle S,s \rangle \rightarrow \langle s\prime \rangle $
Waarbij s de state is: Een functie met het type
$ x \rightarrow a $.
Omdat wij in de syntax geen directe assignment $(x := a)$ meer toestaan, maken wij hier een aanpassing op.\\
We gebruiken nog steeds dezelfde overgang, maar nu met een andere definitie voor de state, waarbij de state equivalent is aan een object:
\[ \langle S,s \rangle \rightarrow \langle s\prime \rangle \]
\[ s = x \rightarrow Inhoud \]
Daarnaast moeten wij nog definiÃ«ren dat aan de start van een programma de state niet leeg is, maar de varnaam $ this $ bind aan het lege Object $ [\enspace] $.
\[ s_{start} = [this \rightarrow [\enspace]]\]
\\
\par
Daarnaast moeten we enkele veranderingen maken aan de manier waarop expressies (Beide arithmisch en booleaans) worden geevalueerd. 
Allereerst is het belangrijk om op de juiste manier een stuk inhoud op te halen. We defineeren een totale functie $ GET $ die een syntactisch construct (De varnaam) en een object neemt. De functionaliteit leggen we vast als:
\[ GET: x \rightarrow (Object \rightarrow Inhoud) \]
\[
GET\llbracket x \rrbracket_o =
\begin{cases}
\begin{matrix}
o(x) & if \enspace x \in o\\
GET\llbracket x \rrbracket_{o(proto)} & otherwise
\end{matrix}
\end{cases}
\]

Na dit te hebben gedefineerd kunnen we met behulp van de GET-functie enkele nieuwe functies defineeren, waarmee we syntactische constructen om kunnen zetten naar getallen en booleaanse variabelen. We defineeren de totale functie $ RA $ die een syntactisch construct (De varnaam) en een object neemt. De functionaliteit leggen we vast als volgt:

\[ RA: x \rightarrow (Object \rightarrow \mathds{Z} ) \]
\[
\begin{matrix}
RA\llbracket n \rrbracket_o & = & \mathcal{N}\llbracket x \rrbracket\\
RA\llbracket x \rrbracket_o & = & RA\llbracket GET\llbracket x \rrbracket_o \rrbracket_o\\
RA\llbracket FROM \enspace var \enspace CALL \enspace x \rrbracket_o & = & RA\llbracket GET\llbracket x \rrbracket_{GET\llbracket var \rrbracket_o} \rrbracket_o\\
RA\llbracket a_1 + a_2 \rrbracket_o & = & RA\llbracket a_1 \rrbracket_o + RA\llbracket a_2 \rrbracket_o\\
RA\llbracket a_1 * a_2 \rrbracket_o & = & RA\llbracket a_1 \rrbracket_o * RA\llbracket a_2 \rrbracket_o\\
RA\llbracket a_1 - a_2 \rrbracket_o & = & RA\llbracket a_1 \rrbracket_o - RA\llbracket a_2 \rrbracket_o\\
\end{matrix}
\]

We defineeren ook eenzelfde totale functie $ RB $:
\[ RB: x \rightarrow (Object \rightarrow {\boldsymbol{tt},\boldsymbol{ff}} ) \]
\[
\begin{matrix}
RB\llbracket true \rrbracket_o & = & \boldsymbol{tt}\\
RB\llbracket false \rrbracket_o & = & \boldsymbol{ff}\\

RB\llbracket x \rrbracket_o & = & RB\llbracket GET\llbracket x \rrbracket_o \rrbracket_o\\

RB\llbracket FROM \enspace var \enspace CALL \enspace x \rrbracket_o & = & RB\llbracket GET\llbracket x \rrbracket_{GET\llbracket var \rrbracket_o} \rrbracket_o\\

RB\llbracket a_1 = a_2 \rrbracket_o & = &
\begin{cases}
\begin{matrix}
\boldsymbol{tt} & if \enspace RA\llbracket a_1 \rrbracket_o = RA\llbracket a_2 \rrbracket_o \\
\boldsymbol{ff} & if \enspace RA\llbracket a_1 \rrbracket_o \not= RA\llbracket a_2 \rrbracket_o
\end{matrix}
\end{cases}\\

RB\llbracket a_1 \leq a_2 \rrbracket_o & = &
\begin{cases}
\begin{matrix}
\boldsymbol{tt} & if \enspace RA\llbracket a_1 \rrbracket_o \leq RA\llbracket a_2 \rrbracket_o \\
\boldsymbol{ff} & if \enspace RA\llbracket a_1 \rrbracket_o > RA\llbracket a_2 \rrbracket_o
\end{matrix}
\end{cases}\\

RB\llbracket \neg b \rrbracket_o & = &
\begin{cases}
\begin{matrix}
\boldsymbol{tt} & if \enspace RB\llbracket b \rrbracket_o = \boldsymbol{ff} \\
\boldsymbol{ff} & if \enspace RB\llbracket b \rrbracket_o = \boldsymbol{tt}
\end{matrix}
\end{cases}\\

RB\llbracket b_1 \wedge b_2 \rrbracket_o & = &
\begin{cases}
\begin{matrix}
\boldsymbol{tt} & if \enspace RB\llbracket b_1 \rrbracket_o = \boldsymbol{tt} and RB\llbracket b_2 \rrbracket_o = \boldsymbol{tt}\\
\boldsymbol{ff} & if \enspace RB\llbracket b_1 \rrbracket_o = \boldsymbol{ff} or RB\llbracket b_2 \rrbracket_o = \boldsymbol{ff}
\end{matrix}
\end{cases}\\

\end{matrix}
\]

Semantiekregels:\\
\renewcommand*{\arraystretch}{2.5}
\[
\begin{matrix}
[skip_{ns}]  & <skip, o> \rightarrow o\\
[comp_{ns}]  & \dfrac{<S1, o> \rightarrow o' <S2, o'> \rightarrow o''}{<S1;S2, o> \rightarrow o''}\\
[if_{ns}^{tt}] & \dfrac{<S1, o> \rightarrow o'}{<\mbox{IF b THEN S1 ELSE S2}, o> \rightarrow o'} &&\mbox{ als }\RB \llbracket b \rrbracket o = tt\\
[if_{ns}^{ff}] & \dfrac{<S2, o> \rightarrow o'}{<\mbox{IF b THEN S1 ELSE S2}, o> \rightarrow o'} &&\mbox{ als }\RB \llbracket b \rrbracket o = ff\\
[while_{ns}^{tt}] & \dfrac{<S, o> \rightarrow o' <\mbox{WHILE b DO S}, o'> \rightarrow o''}{\mbox{WHILE b DO S}, o> \rightarrow o''} &&\mbox{ als }\RB \llbracket b \rrbracket o = tt\\
[while_{ns}^{ff}] & <\mbox{WHILE b DO S}, o> \rightarrow o &&\mbox{ als }\RB \llbracket b \rrbracket o = ff\\
\end{matrix}
\]

%\end{matrix}
%\]
\appendix

\section{Planning}
Vrijdag 29 april: \\Het werkstuk voldoet aan de eisen van eerste versie.\newline\newline %hebben we een alternatief voor 2x \newline?
Dinsdag 10 mei: \\Het hoofdstuk over de syntax van Io is helemaal klaar en willen we al aardig op weg zijn met de semantiek.\newline\newline
Dinsdag 24 mei: \\Het hoofdstuk over de semantiek is compleet. We bedoelen hier niet mee dat dat hoofdstuk helemaal klaar en perfect is, maar
dat het zodanig is dat we het kunnen gebruiken om de rest van het werkstuk te kunnen maken.\newline\newline
Vrijdag 27 mei: \\Het werkstuk voldoet aan de eisen van de tweede versie. Dat wil zeggen: het inleidende hoofdstuk is af, het hoofdstuk over de syntax is af, het hoofdstuk over de semantiek is af, het hoofdstuk over de analyse bevat in elk geval het programma dat geanalyseerd gaat worden.\newline\newline
Vrijdag 17 juni: \\De definitieve versie van het werkstuk is gereed en ingeleverd.

\end{document}  
