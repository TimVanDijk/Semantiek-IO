\title{Semantiek van Io}
\author{
          Tim van Dijk
          S4477073
        \and
          Nikki van der Gouw
          S4463412
        \and
          Robin Tonen 
          S4486668
}
\date{\today}

\documentclass[12pt]{article}
\usepackage{listings} 
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[dutch]{babel}
\usepackage[bottom]{footmisc}
\usepackage{listings}
\graphicspath{{images/}}
\usepackage{stmaryrd}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{ stmaryrd }
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\graphicspath{{images/}}
\lstset{breaklines = true}
\newcommand{\RB}{\mathcal{RB}}
\newcommand{\n}{\newline}

\begin{document}
\maketitle

%TODO: loop tekst na op woordherhaling
\begin{abstract}
Dit werkstuk beschrijft de syntax en semantiek van een door Io geinspireerde uitbreiding van While, genaamd WhileIo. Io is een puur objectge\"orienteerde programmeertaal. Hierbij wordt WhileIo met natuurlijke semantiek beschreven. Vervolgens gebruiken we de beschreven syntax en semantiek om
de mogelijkheden van Io te laten zien.
\end{abstract}

%Zorg dat je een korte inleiding schrijft waarin je zo concreet mogelijk uitlegt wat je gaat doen.
%Beschrijf hierbij ook wat er zo bijzonder is aan het gekozen onderwerp ten opzichte van de standaardtaal While.
%Neem in de inleiding ook alvast een voorbeeldprogramma op waarin iets interessants gebeurt.
%Zo'n programma helpt om duidelijk te krijgen hoe programma's in jullie taal er uitzien.
\section{Introductie Io}
Io, een programmeertaal, is in 2002 gemaakt door Steve Dekorte omdat hij zijn begrip over de werking van programmeertalen wilde verbreden.
Het bijzondere aan Io is dat het een heel minimalistische en puur objectge\"orienteerde programmeertaal is die gebaseerd is op prototypes. De taal is ge\"inspireerd door Smalltalk. Alles, inclusief objecten, bestaat uit `messages' die worden doorgegeven.
Dit houdt in dat er alleen maar objecten bestaan en dat overerving plaats vindt door bestaande objecten te clonen.
Ook is Io een dynamische taal, dus objecten kunnen tijdens runtime uit worden gebreidt.

Hoewel de syntax van Io heel minimalistisch is, gebeurt er veel achter de schermen - meer dan we in dit project kunnen beschrijven.
Het doel van dit werkstuk is om de standaardtaal While uit te breiden met de belangrijkste mogelijkheden van Io.
Deze uitbreiding noemen we WhileIo.
Aangezien het bij Io allemaal draait om objecten en hoe die met elkaar communiceren, zal de kracht van ons project vooral zitten in het uitwerken van die twee concepten.
Verder laten we zien dat hoewel Io geen keywords, zoals `if' en `for', het nog steeds dezelfde uitdrukkingskracht heeft als While. %Of willen we While en WhileIO vergelijken?
Hierbij zullen we een eigen definitie geven van objecten en definieren we onze eigen manier om berichten door te geven aan objecten (message passing).
Hierbij zullen we eerst vastsleggen hoe Io werkt en hoe dit verschilt met het door ons gemaakte WhileIo.
Hierbij zullen we een voorbeeld gebruiken dat in Io geschreven is dat voorbeeld vertalen we naar WhileIo.
Vervolgens leggen we de syntax en semantiek van WhileIo vast door middel van natuurlijke semantiek.
Tot slot werken we het hierboven genoemde voorbeeldprogramma uit met de door ons gedefinieerde semantiek. 

\subsection*{Voorbeeld}
Om een idee te krijgen van hoe een programma eruit ziet in Io, volgt hier een voorbeeld:
\begin{lstlisting}[frame=single]
Sheep := Object clone
Sheep legCount := 4
MutantSheep := Sheep clone
MutantSheep legCount = 7
Dolly := MutantSheep clone
MutantSheep growMoreLegs := method(n, legCount = legCount + n)
Dolly growMoreLegs(2)
\end{lstlisting}
Dit voorbeeld is afkomstig van \url{andriybuday.com/2012/07/io-programming-language.html} en laat een aantal interessante eigenschappen van Io aan bod komen. Laten we eens kijken wat er in dit voorbeeld gebeurt.\newline

In de eerste regel maken we een clone van Object. Object is het prototype dat er altijd vanaf het begin al is,
alle prototypes die er later bij komen zijn op Object gebaseerd.
Zoals de naam al suggereert maak je, als je een prototype clonet, een nieuwe instantie van dat prototye.
%todo: clone maakt een nieuw (leeg) object aan met als prototype het orginele object
Deze nieuwe instantie heeft precies dezelfde structuur en kenmerken als het prototype waar het uit gecloned is.
Als er later veranderingen worden gemaakt aan het prototype dat gecloned is, dan hebben die ook effect op het nieuwe prototype.
Sheep is dus een nieuw prototype die precies hetzelfde kan en eruit ziet als Object.\newline

Dan willen we zeggen dat het schaap vier poten heeft.
We doen dit door Sheep een nieuw attribuut te geven ``legCount'' en dit attribuut stellen we gelijk aan 4.
Hoewel Sheep een clone is van Object, zijn het verschillende instanties, en dus krijgt object er geen attribuut ``legCount'' bij.\newline

Ons schaap is veel te saai. Dit gaan we oplossen door een gemuteerd schaap te maken door een clone te maken van Sheep. Vervolgens zeggen we door het attribuut ``legCount'' op 7 te zetten.\newline

Vervolgens maken we weer een clone van ons gemuteerde schaap. Deze clone noemen we dolly. De naam dolly, is naar conventie zonder hoofdletter geschreven.
Dit is om het idee te geven dat het een instantie is van het object MutantSheep.
Dit is alleen om het programmeren overzichtelijker te maken, want Io maakt geen onderscheid tussen objecten en instanties: er zijn alleen maar prototypes.\newline


Daarna gaan we een nieuwe methode maken en toevoegen aan MutantSheep, namelijk growMoreLegs.
growMoreLegs neemt \'e\'en argument n en verhoogt ``legCount'' met die n. 
Zoals eerder gezegd worden veranderingen op een prototype ook overgedragen op prototypes die eruit gecloned zijn. dolly heeft deze methode nu dus ook en kan er gebruik van maken.\newline

Ten slotte willen we dolly nog een paar extra poten geven; twee om precies te zijn.
Om dit te doen maken we gebruik van de nieuwe methode growMoreLegs.
We roepen de methode growMoreLegs van dolly aan met argument 2.
De methode verhoogt het attribuut legCount van dolly met 2.
Uiteindelijk heeft dolly dus 9 poten.

We hebben de code van het bovenstaande voorbeeld zo letterlijk mogelijk vertaald naar WhileIo.
Het vertaalde voorbeeld is het volgende:
%Dit was best crappy vertaald. Ik heb hem daarom maar opnieuw vertaald. Ik ben er vrij zeker van dat ik fouten heb gemaakt.
%TODO: fix dit
\begin{lstlisting}[frame=single]
Clone this as Sheep;
Set Sheep Slot legCount To 4;
Clone Sheep as MutantSheep;
SET MutantSheep Slot legCount To 7;
Clone MutantSheep as Dolly;
SET MutantSheep Slot growMoreLegs To Set this Slot legCount To x + From this CALL legCount;
FROM Dolly CALL growMoreLegs WITH x := 2;
\end{lstlisting}
%TODO: Als we het voorbeeld houden zoals het hierboven staat dan moeten we assignment toevoegen.
Nadat we de syntax en semantiek van WhileIo uit hebben gewerkt, komen we terug op dit voorbeeld.
We gaan dan met een analyse laten zien dat het inderdaad het verwachte resultaat opleverd.

\pagebreak
\section{Syntax}
%todo: opmaak misschien nog verbeteren
In het hoofdstuk hierboven staat al een voorbeeldprogramma in WhileIo. Maar hoe zit de syntax er precies uit? Dat zullen we in dit hoofdstuk definiëren. Voor WhileIo hebben we de standaardtaal While als uitgangspunt genomen. Daarom komt een groot deel van de syntax ook overeen met deze taal.

Voor het definieren van de Syntax maken we gebruik van de volgende sets:

$n$ is een cijfer, Num. \\
$a$ is een aritmetisch expressie, $Aexp$. \\
$b$ is een booleaanse expressie, $Bexp$. \\
$S$ is een statement, $Stm$. \\
$x$ is een variabele-naam, $Var$. \\



Hierbij kan een variabele-naam naar verschillende typen waarde kan verwijzen, zoals een getal en een object.

We voegen ook een extra type toe:
$E$ is de lege declaratie.

%todo: Wilde we M niet wegdoen?
%todo: Klopt de FROM regel en klopt die me het voorbeeld? Moet er niet nog een WITH bij ofzo

De definities voor aritmetische en booleaanse expressies blijven gelijk: 
\begin{lstlisting}
a  ::= n | a1 + a2 | a1 * a2 | a1 - a2 | var
b ::= true | false | a1 = a2 | a1 <= a2 | ~b | b1 /\ b2 | var 
\end{lstlisting}

Het verschil met While is dat een variabel niet alleen uit de standaard state kunnen komen, maar dat deze ook uit een object gehaald kan worden. 
\begin{lstlisting}
var ::= x | FROM var CALL x
\end{lstlisting}

Onze statements zien er als volgt uit: 
\begin{lstlisting}
S ::= SKIP | S1;S2 | IF b THEN S1 | WHILE b DO S1
| CLONE var_p AS var_c | FROM var CALL x_i Dv | SET var_o SLOT var_i TO i
\end{lstlisting}

Met de volgende hulpdefinities: 
\begin{lstlisting}
i ::= a | b | m
M ::= S END 
Dv ::= E | VAR x := i; Dv
\end{lstlisting}

We hebben dus de volgende drie statements toegevoegd: 
\begin{lstlisting}
	CLONE var_p AS var_c
\end{lstlisting} 
Dit maakt een clone van var\_p met als naam var\_c. 

\begin{lstlisting}
	FROM var CALL x_i Dv
	Dv ::= E | VAR x := i; Dv
\end{lstlisting}
Dit levert het resultaat op als je slot x\_i van object var aanroept met de variabelen Dv. In een slot kan natuurlijk ook een getal of booleaanse waarde zitten, dus Dv kan ook leeg zijn. 

\begin{lstlisting}
	SET var_o SLOT var_i TO i
\end{lstlisting} 
Dit maakt in object var\_o een slot aan met daarin i. i kan zowel een booleaanse expressie, een aritmetische expressie als een methode zijn. 

%todo: constructie woord?
Zoals je kunt zien eindigen niet alle statements in een constructiewoord. Hierdoor is het niet altijd duidelijk wanneer het ene statement is afgelopen en het andere begint. Kijk maar naar:
\begin{lstlisting}
	WHILE x <= 2 DO
	x := x+1;
	x := x+3
\end{lstlisting}
Moet dit geparseerd worden als While b DO (S1;S2) of als (While b DO S1); S2. Om dit probleem tegen te gaan, nemen wij aan dat je door middel van haakjes statements mag groeperen, net zoals bij While.
\pagebreak
\section{Semantiek}

Als basis gebruiken we de semantiek van While, die we op een paar plekken uitbreiden en aanpassen.
Zo blijven de booleaanse waarden en nummers gelijk aan While:

We definieren nummers als:
\begin{lstlisting}
n ::= 0 | 1 | n0 | n1
\end{lstlisting}

Om deze nummers om te zetten naar echte getallen gebruiken we de volgende functie:
$$
\begin{matrix}
\mathcal{N}: Num \rightarrow Z \\
\mathcal{N}\llbracket 0 \rrbracket &= &0  \\
\mathcal{N}\llbracket 1 \rrbracket &= &1 \\
\mathcal{N}\llbracket n0 \rrbracket &= &2 * \mathcal{N}\llbracket n \rrbracket \\
\mathcal{N}\llbracket n1 \rrbracket &= &2 * \mathcal{N}\llbracket n \rrbracket + 1 \\
\end{matrix}
$$

Onze eigen toevoeging is natuurlijk objecten. Deze definieren we als volgt:
$$Object : Var \rightarrow Inhoud$$ 
Hierbij is Inhoud alles watje in een object zou kunnen stoppen: 
$$Inhoud = Z \cup \{tt,ff\} \cup Object \cup Stm$$ 

Hierbij gebruiken we dezelfde notatie als bij WHile om de inhoud van zo'n object weer te geven.
Neem een object o met als waarden x = 4 en y = true. Dit wordt als volgt gerepresenteerd:
$$[x \mapsto 4, y \mapsto tt]$$

Nu de basistypen gedefinieerd zijn kunnen we met de echte semantiek verder. Om te beginnen passen we de basisovergang van While aan. Deze is normaal gedefineerd als:
$ \langle S,s \rangle \rightarrow \langle s\prime \rangle $
Waarbij s de state is: Een functie met het type
$ x \rightarrow a $.
Omdat wij in de syntax geen directe assignment $(x := a)$ meer toestaan, maken wij hier een aanpassing op.\\
We gebruiken nog steeds dezelfde overgang, maar nu met een andere definitie voor de state, waarbij de state equivalent is aan een object:
\[ \langle S,s \rangle \rightarrow \langle s\prime \rangle \]
\[ s = x \rightarrow Inhoud \]
Daarnaast moeten wij nog definiëren dat aan de start van een programma de state niet leeg is, maar de varnaam $ this $ bind aan het lege Object $ [\enspace] $.
\[ s_{start} = [this \rightarrow [\enspace]]\]
\\
\par
Daarnaast moeten we enkele veranderingen maken aan de manier waarop expressies (Beide arithmisch en booleaans) worden geevalueerd. 
Allereerst is het belangrijk om op de juiste manier een stuk inhoud op te halen. We defineeren een totale functie $ GET $ die een syntactisch construct (De varnaam) en een object neemt. De functionaliteit leggen we vast als:
\[ GET: x \rightarrow (Object \rightarrow Inhoud) \]
\[
GET\llbracket x \rrbracket_o =
\begin{cases}
\begin{matrix}
o(x) & if \enspace x \in o\\
GET\llbracket x \rrbracket_{o(proto)} & otherwise
\end{matrix}
\end{cases}
\]

Na dit te hebben gedefineerd kunnen we met behulp van de GET-functie enkele nieuwe functies defineeren, waarmee we syntactische constructen om kunnen zetten naar getallen en booleaanse variabelen. We defineeren de totale functie $ RA $ die een syntactisch construct (De varnaam) en een object neemt. De functionaliteit leggen we vast als volgt:

\[ RA: x \rightarrow (Object \rightarrow \mathds{Z} ) \]
\[
\begin{matrix}
RA\llbracket n \rrbracket_o & = & \mathcal{N}\llbracket x \rrbracket\\
RA\llbracket x \rrbracket_o & = & RA\llbracket GET\llbracket x \rrbracket_o \rrbracket_o\\
RA\llbracket FROM \enspace var \enspace CALL \enspace x \rrbracket_o & = & RA\llbracket GET\llbracket x \rrbracket_{GET\llbracket var \rrbracket_o} \rrbracket_o\\
RA\llbracket a_1 + a_2 \rrbracket_o & = & RA\llbracket a_1 \rrbracket_o + RA\llbracket a_2 \rrbracket_o\\
RA\llbracket a_1 * a_2 \rrbracket_o & = & RA\llbracket a_1 \rrbracket_o * RA\llbracket a_2 \rrbracket_o\\
RA\llbracket a_1 - a_2 \rrbracket_o & = & RA\llbracket a_1 \rrbracket_o - RA\llbracket a_2 \rrbracket_o\\
\end{matrix}
\]

We defineeren ook eenzelfde totale functie $ RB $:
\[ RB: x \rightarrow (Object \rightarrow {\boldsymbol{tt},\boldsymbol{ff}} ) \]
\[
\begin{matrix}
RB\llbracket true \rrbracket_o & = & \boldsymbol{tt}\\
RB\llbracket false \rrbracket_o & = & \boldsymbol{ff}\\

RB\llbracket x \rrbracket_o & = & RB\llbracket GET\llbracket x \rrbracket_o \rrbracket_o\\

RB\llbracket FROM \enspace var \enspace CALL \enspace x \rrbracket_o & = & RB\llbracket GET\llbracket x \rrbracket_{GET\llbracket var \rrbracket_o} \rrbracket_o\\

RB\llbracket a_1 = a_2 \rrbracket_o & = &
\begin{cases}
\begin{matrix}
\boldsymbol{tt} & if \enspace RA\llbracket a_1 \rrbracket_o = RA\llbracket a_2 \rrbracket_o \\
\boldsymbol{ff} & if \enspace RA\llbracket a_1 \rrbracket_o \not= RA\llbracket a_2 \rrbracket_o
\end{matrix}
\end{cases}\\

RB\llbracket a_1 \leq a_2 \rrbracket_o & = &
\begin{cases}
\begin{matrix}
\boldsymbol{tt} & if \enspace RA\llbracket a_1 \rrbracket_o \leq RA\llbracket a_2 \rrbracket_o \\
\boldsymbol{ff} & if \enspace RA\llbracket a_1 \rrbracket_o > RA\llbracket a_2 \rrbracket_o
\end{matrix}
\end{cases}\\

RB\llbracket \neg b \rrbracket_o & = &
\begin{cases}
\begin{matrix}
\boldsymbol{tt} & if \enspace RB\llbracket b \rrbracket_o = \boldsymbol{ff} \\
\boldsymbol{ff} & if \enspace RB\llbracket b \rrbracket_o = \boldsymbol{tt}
\end{matrix}
\end{cases}\\

RB\llbracket b_1 \wedge b_2 \rrbracket_o & = &
\begin{cases}
\begin{matrix}
\boldsymbol{tt} & if \enspace RB\llbracket b_1 \rrbracket_o = \boldsymbol{tt} and RB\llbracket b_2 \rrbracket_o = \boldsymbol{tt}\\
\boldsymbol{ff} & if \enspace RB\llbracket b_1 \rrbracket_o = \boldsymbol{ff} or RB\llbracket b_2 \rrbracket_o = \boldsymbol{ff}
\end{matrix}
\end{cases}\\

\end{matrix}
\]

Semantiekregels:\\
\renewcommand*{\arraystretch}{2.5}
\[
\begin{matrix}
[skip_{ns}]  & <skip, o> \rightarrow o\\
[comp_{ns}]  & \dfrac{<S1, o> \rightarrow o' <S2, o'> \rightarrow o''}{<S1;S2, o> \rightarrow o''}\\
[if_{ns}^{tt}] & \dfrac{<S1, o> \rightarrow o'}{<\mbox{IF b THEN S1 ELSE S2}, o> \rightarrow o'} &&\mbox{ als }\RB \llbracket b \rrbracket o = tt\\
[if_{ns}^{ff}] & \dfrac{<S2, o> \rightarrow o'}{<\mbox{IF b THEN S1 ELSE S2}, o> \rightarrow o'} &&\mbox{ als }\RB \llbracket b \rrbracket o = ff\\
[while_{ns}^{tt}] & \dfrac{<S, o> \rightarrow o' <\mbox{WHILE b DO S}, o'> \rightarrow o''}{\mbox{WHILE b DO S}, o> \rightarrow o''} &&\mbox{ als }\RB \llbracket b \rrbracket o = tt\\
[while_{ns}^{ff}] & <\mbox{WHILE b DO S}, o> \rightarrow o &&\mbox{ als }\RB \llbracket b \rrbracket o = ff\\
\end{matrix}
\]
\[
\begin{matrix}
[clone_{ns}] &
\langle CLONE \enspace var_p \enspace AS \enspace var_c, o\rangle 
\rightarrow
\langle o[var_c \mapsto [proto \mapsto GET\llbracket var_p \rrbracket_o]]\rangle\\
[set_{ns}] &
\langle SET \enspace var_t \enspace SLOT \enspace var_i \enspace TO \enspace i, o \rangle
\rightarrow
\langle o[var_t \mapsto GET\llbracket var_t \rrbracket_o[var_i \mapsto i]]\rangle\\
[call_{ns}] &
\dfrac
{
	\langle Dv, GET\llbracket var \rrbracket_o \rangle \rightarrow var\prime
	\quad
	\langle  GET\llbracket x_i \rrbracket_{var\prime}, var\prime \rangle
	\rightarrow
	\langle o\prime \rangle
}
{
	\langle FROM \enspace var \enspace CALL \enspace x_i \enspace Dv,o \rangle
	\rightarrow
	\langle o\prime \rangle
}\\
[DvSkip_{ns}] &
\langle E,o \rangle \rightarrow \langle o \rangle\\
[DvVar_{ns}] &
\dfrac
{	\langle Dv,o[x \mapsto i] \rangle \rightarrow \langle o\prime \rangle }
{
	\langle VAR \enspace x \enspace := \enspace i; \enspace Dv, o \rangle
	\rightarrow
	\langle o\prime \rangle
}

\end{matrix}
\]

%\end{matrix}
%\]
\appendix

\section{Planning}
Vrijdag 29 april: \\Het werkstuk voldoet aan de eisen van eerste versie.\newline\newline %hebben we een alternatief voor 2x \newline?
Dinsdag 10 mei: \\Het hoofdstuk over de syntax van Io is helemaal klaar en willen we al aardig op weg zijn met de semantiek.\newline\newline
Dinsdag 24 mei: \\Het hoofdstuk over de semantiek is compleet. We bedoelen hier niet mee dat dat hoofdstuk helemaal klaar en perfect is, maar
dat het zodanig is dat we het kunnen gebruiken om de rest van het werkstuk te kunnen maken.\newline\newline
Vrijdag 27 mei: \\Het werkstuk voldoet aan de eisen van de tweede versie. Dat wil zeggen: het inleidende hoofdstuk is af, het hoofdstuk over de syntax is af, het hoofdstuk over de semantiek is af, het hoofdstuk over de analyse bevat in elk geval het programma dat geanalyseerd gaat worden.\newline\newline
Vrijdag 17 juni: \\De definitieve versie van het werkstuk is gereed en ingeleverd.

\end{document}  
